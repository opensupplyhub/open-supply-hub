import logging
from django.apps import apps
from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.db import transaction, connection

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = "Sync data from OS Hub (default) to RBA (rba DB) by UUID"

    def add_arguments(self, parser):
        parser.add_argument('--table', required=True, help='Model name to sync (app_label.ModelName)')
        parser.add_argument('--dry-run', action='store_true', help='Only show changes, do not apply them')

    def __update_sequence(self, model, using='rba'):
        """Update the sequence for a model's primary key to prevent ID conflicts"""
        try:
            # Get the table name
            table_name = model._meta.db_table
            
            # Get the primary key field name
            pk_field = model._meta.pk.name
            
            # Construct sequence name (PostgreSQL convention)
            sequence_name = f"{table_name}_{pk_field}_seq"
            
            # Update the sequence to the maximum ID value
            with connection.cursor() as cursor:
                cursor.execute(f"""
                    SELECT setval('{sequence_name}', 
                        COALESCE((SELECT MAX({pk_field}) FROM {table_name}), 1)
                    );
                """)
                
            logger.info(f"Updated sequence {sequence_name} for {table_name}")
            
        except Exception as e:
            logger.warning(f"Failed to update sequence for {model._meta.db_table}: {e}")

    def __prepare_objects_for_sync(self, objects, model):
        """Prepare objects for sync by removing ID to avoid conflicts"""
        prepared_objects = []
        
        for obj in objects:
            # Create a new instance without the ID to let the target DB generate a new one
            obj_data = {}
            
            # Copy all fields except the primary key
            for field in model._meta.fields:
                if field.primary_key:
                    continue  # Skip the primary key field
                
                value = getattr(obj, field.name)
                obj_data[field.name] = value
            
            # Create a new model instance with the copied data
            new_obj = model(**obj_data)
            prepared_objects.append(new_obj)
        
        return prepared_objects

    def __sync_objects_to_rba(self, model, prepared_objs):
        """Sync prepared objects to RBA database"""
        model.objects.using('rba').bulk_create(prepared_objs, batch_size=500)
        
        # Update the sequence after bulk insert to prevent ID conflicts
        if prepared_objs:
            self.__update_sequence(model, using='rba')

    @transaction.atomic(using='rba')
    def handle(self, *args, **options):
        table = options['table']
        dry_run = options['dry_run']

        try:
            app_label, model_name = table.split('.')
            model = apps.get_model(app_label, model_name)
        except (ValueError, LookupError):
            raise CommandError("Invalid table format. Use app_label.ModelName")

        logger.info(f"Syncing table {table} from OS Hub (default) â†’ RBA. Dry run: {dry_run}")

        # Debug: Show RBA database connection info
        rba_db_config = settings.DATABASES['rba']
        logger.info(f"RBA DB Config: {rba_db_config}")

        # Fetch all records from OSHub (default DB)
        source_qs = model.objects.using('default').all()
        table_msg = ''
        if table:
            table_msg = f"table {table}"
        logger.info(f"Fetched {source_qs.count()} records from OS Hub {table_msg}.")

        # Get UUIDs from RBA
        existing_uuids = set(
            model.objects.using('rba').values_list('uuid', flat=True)
        )
        logger.info(f"Found {len(existing_uuids)} existing UUIDs in RBA.")

        # Filter only new records by UUID
        new_objs = [
            obj for obj in source_qs
            if getattr(obj, 'uuid', None) not in existing_uuids
        ]
        logger.info(f"{len(new_objs)} new records to insert into RBA.")

        if dry_run:
            logger.warning(f"[DRY-RUN] Would insert {len(new_objs)} records into RBA.")
            return

        # Prepare objects for sync (remove IDs to avoid conflicts)
        prepared_objs = self.__prepare_objects_for_sync(new_objs, model)
        logger.info(f"Prepared {len(prepared_objs)} objects for sync (IDs will be generated by RBA)")

        # Write to RBA
        self.__sync_objects_to_rba(model, prepared_objs)

        logger.info(f"Successfully inserted {len(prepared_objs)} new records into RBA.")

