# Frontend (React) Test Conventions

This document captures practical, project-specific patterns used in `src/react/src/__tests__/components/` and should be followed for new and updated tests.

## How to Run Tests (MANDATORY)

Always use the Docker command templates from `.cursor-rules`:

```bash
# React/Jest (single file)
docker exec -it open-supply-hub-react-1 /bin/bash -lc 'yarn test ./__tests__/components/<TestFile>.test.js --coverage=none'
```

Do not run `npm/yarn test` outside the container.

## File Location and Naming

- Place component tests under `src/react/src/__tests__/components/`.
- Name files `<ComponentName>.test.js` (or `.jsx` if applicable).

## Rendering With Redux Store

- Use `renderWithProviders` to render any component connected to Redux.
- Inject `preloadedState` for deterministic tests.

```javascript
import renderWithProviders from '../../util/testUtils/renderWithProviders';

const preloadedState = {
    auth: { user: { user: { email: 'test@example.com', name: 'Org', isAnon: false } } },
};

const { reduxStore } = renderWithProviders(<MyComponent />, { preloadedState });
```

Notes:
- `renderWithProviders` wraps with `Provider` and uses the app's `setupStore`.
- Return value includes `reduxStore` if you need to inspect dispatched actions/state.

## Routing Mocks (react-router-dom)

If a component or HOC uses `useHistory`/`useLocation`, mock them explicitly:

```javascript
const mockHistoryPush = jest.fn();

jest.mock('react-router-dom', () => {
    const actual = jest.requireActual('react-router-dom');
    return {
        ...actual,
        useHistory: () => ({ push: mockHistoryPush }),
        useLocation: () => ({ pathname: '/path', search: '', hash: '', state: null }),
    };
});
```

- This is required for HOCs like `withScrollReset` that call `useLocation`.

## DOM and Events (React Testing Library)

- Prefer `screen.getByRole`, `getByText`, and `getByTestId` for queries.
- Use `fireEvent` for simple events. For async flows, prefer `userEvent` (when added).

```javascript
import { fireEvent, screen } from '@testing-library/react';

fireEvent.change(screen.getByTestId('relationship-select'), { target: { value: 'owner' } });
fireEvent.click(screen.getByRole('button', { name: /Return to Claims/i }));
```

## Component Mocks (e.g., StyledSelect)

Mock complex UI (like custom selects) with a simple native element that preserves behavior:

```javascript
jest.mock('../../components/Filters/StyledSelect', () => props => {
    const { options, value, onChange, onBlur, placeholder, name } = props;
    return (
        <select data-testid="relationship-select" name={name} value={value ? value.value : ''}
                onChange={e => onChange(options.find(opt => opt.value === e.target.value))}
                onBlur={onBlur}>
            <option value="">{placeholder}</option>
            {options.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
        </select>
    );
});
```

## Window/Environment Quirks

- jsdom does not implement `window.scrollTo`. Silence harmless warnings by stubbing when needed:

```javascript
beforeAll(() => {
    if (!window.scrollTo) { window.scrollTo = jest.fn(); }
});
```

## Test Structure and Hygiene

- Use a `defaultProps` object for minimal required props.
- Provide a `renderComponent` helper inside the test for consistency.
- Call `jest.clearAllMocks()` in `afterEach`.

```javascript
const defaultProps = { /* minimal props */ };
const renderComponent = (props = {}, state = preloadedState) =>
    renderWithProviders(<MyComponent {...defaultProps} {...props} />, { preloadedState: state });

afterEach(() => { jest.clearAllMocks(); });
```

## Assertions

- Prefer user-visible assertions (text, role) over implementation details.
- For dialogs, use role and text:

```javascript
expect(screen.getByText(/Not Eligible/i)).toBeInTheDocument();
expect(screen.getByRole('button', { name: /Return to Claims/i })).toBeInTheDocument();
```

## Constants and Routes

- Import shared constants (e.g., `mainRoute`) from `src/react/src/util/constants` and assert on routing interactions using the mocked `history.push`.

```javascript
import { mainRoute } from '../../util/constants';
expect(mockHistoryPush).toHaveBeenCalledWith(mainRoute);
```

## Do/Don't Checklist

- Do: Render with `renderWithProviders` for anything using Redux.
- Do: Mock `useHistory` and `useLocation` when components/HOCs use routing.
- Do: Mock complex inputs (like `StyledSelect`) to simple controls that trigger `onChange` with the expected shape.
- Do: Inject `preloadedState` for auth/user-dependent rendering.
- Don't: Rely on implementation details (internal state, class names).
- Don't: Run tests outside Docker; always use the `docker exec` template.

## Example Minimal Pattern

```javascript
import React from 'react';
import { fireEvent, screen } from '@testing-library/react';
import renderWithProviders from '../../util/testUtils/renderWithProviders';
import Component from '../../components/Path/Component';

const mockHistoryPush = jest.fn();

jest.mock('react-router-dom', () => {
    const actual = jest.requireActual('react-router-dom');
    return { ...actual, useHistory: () => ({ push: mockHistoryPush }), useLocation: () => ({ pathname: '/' }) };
});

const preloadedState = { auth: { user: { user: { isAnon: false } } } };

const defaultProps = { /* required props */ };
const renderComponent = (props = {}, state = preloadedState) =>
    renderWithProviders(<Component {...defaultProps} {...props} />, { preloadedState: state });

test('happy path', () => {
    renderComponent();
    fireEvent.click(screen.getByRole('button', { name: /Continue/i }));
    expect(mockHistoryPush).toHaveBeenCalled();
});
```

---

If a new pattern becomes common (e.g., API request mocking, timers, feature flags), extend this file with a short, copy-ready snippet.


# Django/Python Test Conventions

This section captures patterns from `src/django/api/tests/` and should guide all new Django tests.

## How to Run Tests (MANDATORY)

Always use the Docker command templates from `.cursor-rules`:

```bash
# Run a module
docker exec -it open-supply-hub-django-1 bash -lc "python ./manage.py test api.tests.test_production_locations_get"

# Run a specific TestCase
docker exec -it open-supply-hub-django-1 bash -lc "python ./manage.py test api.tests.test_production_locations_get.TestProductionLocationsViewSet"

# Run a specific test method
docker exec -it open-supply-hub-django-1 bash -lc "python ./manage.py test api.tests.test_production_locations_get.TestProductionLocationsViewSet.test_get_production_locations"
```

Do not run `python manage.py test` outside the container. Do not use `docker compose run` for tests.

## Linting (flake8)

For modified Python files, validate with flake8 using the exact project command:

```bash
docker compose run --rm --no-deps --entrypoint flake8 django --exclude 'settings.py, manage.py, *.pyc, api/migrations' path/to/modified/file.py
```

Follow the Python line length (â‰¤79 chars) and formatting rules noted in `.cursor-rules`.

## Test Discovery and Naming

- Files: `test_*.py` under `src/django/api/tests/`.
- Classes: `Test*` (unittest-compatible).
- Methods: `test_*`.

## Base Classes

- Prefer `rest_framework.test.APITestCase` for API endpoint tests. It provides `self.client` and integrates well with DRF responses (`api_res.data`).
- Use `django.test.TestCase` for model/service logic (no API client needed).
- Consider `TransactionTestCase` only when you need behavior across transactions.

## Common Setup Patterns

- Create users, contributors, and related models in `setUp`.
- Example: see `facility_api_test_case_base.py` which provisions a `User`, `Contributor`, `FacilityList`, `Source`, `FacilityListItem`, `Facility`, and `FacilityMatch`, plus helpers like `join_group_and_login()`.

```python
from rest_framework.test import APITestCase
from django.contrib.gis.geos import Point

class MyTestCase(APITestCase):
    def setUp(self):
        # create users/objects; example of Point for geo fields
        pass
```

- If reusing large setups across many tests, inherit from a base like `FacilityAPITestCaseBase`.

## Client Usage and Assertions

- Use `self.client.get/post/patch/delete` and assert on `status_code` via `rest_framework.status`.
- Prefer inspecting `api_res.data` for response content rather than raw body.

```python
from rest_framework import status
api_res = self.client.get("/api/v1/production-locations/")
self.assertEqual(api_res.status_code, status.HTTP_200_OK)
self.assertIn("data", api_res.data)
```

## Mocking External Services

- Use `unittest.mock.patch` with a string import path. Start in `setUp` and stop in `tearDown` or via `addCleanup`.
- Pattern drawn from `test_production_locations_get.py`:

```python
import unittest.mock
OPEN_SEARCH_SERVICE = "api.views.v1.production_locations.OpenSearchService"

class TestProductionLocationsViewSet(APITestCase):
    def setUp(self):
        patcher = unittest.mock.patch(OPEN_SEARCH_SERVICE)
        self.addCleanup(patcher.stop)
        self.search_mock = patcher.start()
        self.search_index_mock = self.search_mock.return_value.search_index
```

- Set `self.search_index_mock.return_value` to the desired payload, then call `self.client.get(...)` and assert.

## Auth, Permissions, and Feature Flags

- Log in with `self.client.login(email=..., password=...)` when needed.
- Assign groups/permissions via Django auth. See `FacilityAPITestCaseBase.join_group_and_login()` for enabling `FeatureGroups.CAN_SUBMIT_FACILITY`.

## Geo and GIS Fields

- Use `django.contrib.gis.geos.Point` for geographic fields in test data.

## URL Paths vs reverse()

- Many existing tests use explicit URL strings (e.g., `/api/v1/production-locations/`). Maintain consistency unless refactoring; `reverse()` is acceptable when names are stable.

## Minimal Example

```python
import unittest.mock
from rest_framework.test import APITestCase
from rest_framework import status

OPEN_SEARCH_SERVICE = "api.views.v1.production_locations.OpenSearchService"

class TestProductionLocationsViewSet(APITestCase):
    def setUp(self):
        patcher = unittest.mock.patch(OPEN_SEARCH_SERVICE)
        self.addCleanup(patcher.stop)
        self.search_mock = patcher.start()
        self.search_index_mock = self.search_mock.return_value.search_index
        self.os_id = "CN2021250D1DTN7"

    def test_get_production_locations(self):
        self.search_index_mock.return_value = {"count": 0, "data": []}
        api_res = self.client.get("/api/v1/production-locations/")
        self.assertEqual(api_res.status_code, status.HTTP_200_OK)
        self.assertIn("data", api_res.data)

    def test_get_single_production_location(self):
        self.search_index_mock.return_value = {
            "count": 1,
            "data": [{"os_id": self.os_id, "name": "location1"}],
        }
        api_res = self.client.get(f"/api/v1/production-locations/{self.os_id}/")
        self.assertEqual(api_res.status_code, status.HTTP_200_OK)
        self.assertEqual(api_res.data.get("os_id"), self.os_id)
```

## Do/Don't Checklist

- Do: Use `APITestCase` for endpoints; `TestCase` for pure logic.
- Do: Patch external services with full import paths; stop patches with `addCleanup`.
- Do: Assert with DRF `status` and inspect `api_res.data`.
- Do: Keep lines â‰¤ 79 characters; wrap long lines with parentheses.
- Don't: Depend on global state or order between tests.
- Don't: Hit real external services; always mock.

